"use strict";(self.webpackChunkneo_dev_portal=self.webpackChunkneo_dev_portal||[]).push([[3401],{3905:function(t,e,n){n.d(e,{Zo:function(){return s},kt:function(){return m}});var a=n(67294);function r(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function l(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,a)}return n}function o(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?l(Object(n),!0).forEach((function(e){r(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function i(t,e){if(null==t)return{};var n,a,r=function(t,e){if(null==t)return{};var n,a,r={},l=Object.keys(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||(r[n]=t[n]);return r}(t,e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);for(a=0;a<l.length;a++)n=l[a],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(r[n]=t[n])}return r}var c=a.createContext({}),d=function(t){var e=a.useContext(c),n=e;return t&&(n="function"==typeof t?t(e):o(o({},e),t)),n},s=function(t){var e=d(t.components);return a.createElement(c.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(t,e){var n=t.components,r=t.mdxType,l=t.originalType,c=t.parentName,s=i(t,["components","mdxType","originalType","parentName"]),u=d(n),m=r,f=u["".concat(c,".").concat(m)]||u[m]||p[m]||l;return n?a.createElement(f,o(o({ref:e},s),{},{components:n})):a.createElement(f,o({ref:e},s))}));function m(t,e){var n=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var l=n.length,o=new Array(l);o[0]=u;var i={};for(var c in e)hasOwnProperty.call(e,c)&&(i[c]=e[c]);i.originalType=t,i.mdxType="string"==typeof t?t:r,o[1]=i;for(var d=2;d<l;d++)o[d]=n[d];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},24455:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return d},toc:function(){return s},default:function(){return u}});var a=n(87462),r=n(63366),l=(n(67294),n(3905)),o=["components"],i={},c="NEF and Manifest Files",d={unversionedId:"n3/develop/write/manifest",id:"n3/develop/write/manifest",isDocsHomePage:!1,title:"NEF and Manifest Files",description:"Neo N3 uses the NEF (NEO Executable Format) and Manifest files as a replacement of the AVM and ABI files in Neo Legacy.",source:"@site/docs/n3/develop/write/manifest.md",sourceDirName:"n3/develop/write",slug:"/n3/develop/write/manifest",permalink:"/website/docs/n3/develop/write/manifest",editUrl:"https://github.com/neo-project/neo-dev-portal/blob/master/docs/n3/develop/write/manifest.md",tags:[],version:"current",lastUpdatedBy:"Apisit Toompkadee",frontMatter:{},sidebar:"docs",previous:{title:"Smart Contract Framework (C",permalink:"/website/docs/n3/develop/write/framework"},next:{title:"NEP-11",permalink:"/website/docs/n3/develop/write/nep11"}},s=[{value:"NEF",id:"nef",children:[]},{value:"Manifest",id:"manifest",children:[]}],p={toc:s};function u(t){var e=t.components,n=(0,r.Z)(t,o);return(0,l.kt)("wrapper",(0,a.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"nef-and-manifest-files"},"NEF and Manifest Files"),(0,l.kt)("p",null,"Neo N3 uses the NEF (NEO Executable Format) and Manifest files as a replacement of the AVM and ABI files in Neo Legacy."),(0,l.kt)("p",null,"When a contract is compiled successfully, the compiler generates both the NEF file and Manifest file. These two files are also needed when you deploy a contract or upgrade a contract."),(0,l.kt)("h2",{id:"nef"},"NEF"),(0,l.kt)("p",null,"The NEF file includes the following fields."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Field"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Magic"),(0,l.kt)("td",{parentName:"tr",align:null},"uint32"),(0,l.kt)("td",{parentName:"tr",align:null},"The Magic value of the blockchain.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Compiler"),(0,l.kt)("td",{parentName:"tr",align:null},"byte","[64]"),(0,l.kt)("td",{parentName:"tr",align:null},"Compiler name and version")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Source"),(0,l.kt)("td",{parentName:"tr",align:null},"byte","[64]"),(0,l.kt)("td",{parentName:"tr",align:null},"The source code address of the contract")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Reserve"),(0,l.kt)("td",{parentName:"tr",align:null},"byte","[2]"),(0,l.kt)("td",{parentName:"tr",align:null},"The field reserved for future extensions. It must be 0.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Tokens"),(0,l.kt)("td",{parentName:"tr",align:null},"MethodToken[]"),(0,l.kt)("td",{parentName:"tr",align:null},"Method tokens.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Reserve"),(0,l.kt)("td",{parentName:"tr",align:null},"byte","[2]"),(0,l.kt)("td",{parentName:"tr",align:null},"The field reserved for future extensions. It must be 0.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Script"),(0,l.kt)("td",{parentName:"tr",align:null},"Byte[]"),(0,l.kt)("td",{parentName:"tr",align:null},"The contract script")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Checksum"),(0,l.kt)("td",{parentName:"tr",align:null},"uint32"),(0,l.kt)("td",{parentName:"tr",align:null},"The first four bytes after two-time SHA256 hashed")))),(0,l.kt)("h2",{id:"manifest"},"Manifest"),(0,l.kt)("p",null,"Before deploying the contract, you need to explicitly declare the contract functions and permissions in the manifest file, which affects the contract behavior when running."),(0,l.kt)("p",null,"The Manifest file includes the following fields."),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Field"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Comment"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Name"),(0,l.kt)("td",{parentName:"tr",align:null},"string"),(0,l.kt)("td",{parentName:"tr",align:null},"Contract name")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Groups"),(0,l.kt)("td",{parentName:"tr",align:null},"ContractGroup[] Consisting of a public key and a signature on the contract hash"),(0,l.kt)("td",{parentName:"tr",align:null},"Defines a group of trusted contracts. Contracts in a group trusts each other and can be invoked by each other,  without prompting the user any warnings. For example, a series of contracts that call each other for a DeFi project. A group is identified by a public key and must has a signature for the contract hash to prove that the contract is included in the group.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"SupportedStandards"),(0,l.kt)("td",{parentName:"tr",align:null},"string[]"),(0,l.kt)("td",{parentName:"tr",align:null},"Supported NEP standard, equivalent to NEP-10 in Neo Legacy.x")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Abi"),(0,l.kt)("td",{parentName:"tr",align:null},"ContractAbi"),(0,l.kt)("td",{parentName:"tr",align:null},"NEP-14 (NeoContract ABI) Description of smart contract methods (name, parameters, return value, offset, safe or not), events (name, parameters)")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Permissions"),(0,l.kt)("td",{parentName:"tr",align:null},"ContractPermission[] Consisting of the contract and its method names"),(0,l.kt)("td",{parentName:"tr",align:null},"This field is an array containing a permission object, which defines other contracts and methods that the contract wants to call. The contract can be ScriptHash, Group, or wildcard ",(0,l.kt)("em",{parentName:"td"},". The method is the method name or wildcard "),". Contracts or methods not declared in the manifest cannot be called by the contract.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Trusts"),(0,l.kt)("td",{parentName:"tr",align:null},"WildcardContainer<UInt160",">"),(0,l.kt)("td",{parentName:"tr",align:null},"Defines other contracts trusted by the contract. The contract can be ScriptHash, Group, or wildcard *. If a contract is trusted, the user will not receive any warning message when the contract is called.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},"Extra"),(0,l.kt)("td",{parentName:"tr",align:null},"object"),(0,l.kt)("td",{parentName:"tr",align:null},"Other user-defined data, such as developer, email, URL, contract profile, etc.")))))}u.isMDXComponent=!0}}]);