"use strict";(self.webpackChunkneo_dev_portal=self.webpackChunkneo_dev_portal||[]).push([[8971],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return m}});var s=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,s,o=function(e,t){if(null==e)return{};var n,s,o={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=s.createContext({}),c=function(e){var t=s.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=c(e.components);return s.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},h=s.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=r(e,["components","mdxType","originalType","parentName"]),h=c(n),m=o,p=h["".concat(l,".").concat(m)]||h[m]||d[m]||a;return n?s.createElement(p,i(i({ref:t},u),{},{components:n})):s.createElement(p,i({ref:t},u))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=h;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:o,i[1]=r;for(var c=2;c<a;c++)i[c]=n[c];return s.createElement.apply(null,i)}return s.createElement.apply(null,n)}h.displayName="MDXCreateElement"},25903:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return r},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return h}});var s=n(87462),o=n(63366),a=(n(67294),n(3905)),i=["components"],r={},l="Consensus Mechanism",c={unversionedId:"n3/foundation/consensus/dbft",id:"n3/foundation/consensus/dbft",isDocsHomePage:!1,title:"Consensus Mechanism",description:"Overview",source:"@site/docs/n3/foundation/consensus/dbft.md",sourceDirName:"n3/foundation/consensus",slug:"/n3/foundation/consensus/dbft",permalink:"/website/docs/n3/foundation/consensus/dbft",editUrl:"https://github.com/neo-project/neo-dev-portal/blob/master/docs/n3/foundation/consensus/dbft.md",tags:[],version:"current",lastUpdatedBy:"Apisit Toompkadee",frontMatter:{},sidebar:"docs",previous:{title:"Consensus Protocol",permalink:"/website/docs/n3/foundation/consensus/consensus_protocol"},next:{title:"Consensus Nodes Election",permalink:"/website/docs/n3/foundation/consensus/vote_validator"}},u=[{value:"Overview",id:"overview",children:[]},{value:"System Model",id:"system-model",children:[]},{value:"The Algorithm",id:"the-algorithm",children:[{value:"General Procedures",id:"general-procedures",children:[]},{value:"View Change",id:"view-change",children:[]},{value:"Recovery Mechanism",id:"recovery-mechanism",children:[]}]},{value:"Fault Tolerance of dBFT2.0",id:"fault-tolerance-of-dbft20",children:[]},{value:"Single Block Finality of dBFT2.0",id:"single-block-finality-of-dbft20",children:[]}],d={toc:u};function h(e){var t=e.components,r=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,s.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"consensus-mechanism"},"Consensus Mechanism"),(0,a.kt)("h2",{id:"overview"},"Overview"),(0,a.kt)("p",null,"A blockchain is a decentralized distributed ledger system. It could be used for registration and issuance of digitalized assets, property right certificates, credit points and so on. It enables transfer, payment, and transactions in a peer-to-peer way. The blockchain technology was originally proposed by Satoshi Nakamoto in a cryptography mailing list, i.e. the Bitcoin. Since then, numerous applications based on the blockchain emerged, such as e-cash systems, stock equity exchanges and Smart Contract systems."),(0,a.kt)("p",null,"A blockchain system is advantageous over a traditional centralized ledger system for its full-openness, immutability and anti-multiple-spend characters, and it does not rely on any kind of trusted third-party."),(0,a.kt)("p",null,"However, like all distributed systems, blockchain systems are challenged with network latency, transmission errors, software bugs, security loopholes and black-hat hacker threats. Moreover, its decentralized nature suggests that no participant of the system cannot be trusted. Malicious nodes may emerge, so does data difference due to conflicting interests."),(0,a.kt)("p",null,"To counter these potential errors, a blockchain system is in need of an efficient consensus mechanism to ensure that every node has a copy of a recognized version of the total ledger. Traditional fault tolerance mechanisms concerning certain problems may not be completely capable of tackling the issue that distributed and blockchain systems are faced with. A universal cure-to-all fault tolerance solution is in need."),(0,a.kt)("p",null,"Proof-of-Work mechanism, employed by the Bitcoin, addresses this issue rather brilliantly. But it comes with an obvious price, i.e. significant electricity cost and energy consumption. Further, with Bitcoin\u2019s existence, new blockchains must find different hashing algorithms, so as to prevent computational attacks from it. For example, Litecoin adopts SCRYPT, rather than Bitcoin\u2019s SHA256."),(0,a.kt)("p",null,"Byzantine Fault Tolerance mechanism is a universal solution for distributed systems. NEO proposes dBFT (delegated Byzantine Fault Tolerance) consensus algorithm based on PBFT   (Practical Byzantine Fault Tolerance) algorithm. Algorithm dBFT determines validator set according to real-time blockchain voting, which effectively enhances the effectiveness of the algorithm, bringing block time and transaction confirmation time savings. dBFT2.0 as an upgraded version was released in Mar. 2019, which improves robustness and safety by introducing 3-stage consensus as well as a recovery mechanism."),(0,a.kt)("h2",{id:"system-model"},"System Model"),(0,a.kt)("p",null,"A blockchain is a distributed ledger system in which participants connect with each other via a peer-to-peer network. All messages within it will be sent by broadcasting. Two types of roles exist: Ordinary nodes and Bookkeeping nodes. Ordinary nodes use the system to transfer and exchange, accepting ledger data; while bookkeeping nodes provide accounting service for the entire network and maintain the ledger. "),(0,a.kt)("p",null,"Hypothetically, in this system, messages may subject to loss, damage, latency and repetition. Also, the sending order may not necessarily be consistent with the receiving order of messages. The activities of nodes could be arbitrary, they may join and quit the network at any time; they may also dump and falsify information or simply stop working. Artificial or non-artificial glitches may occur as well."),(0,a.kt)("p",null,"Integrity and Authenticity of information transmission are ensured with cryptography while senders must attach signatures to the hash value of the message sent. "),(0,a.kt)("h2",{id:"the-algorithm"},"The Algorithm"),(0,a.kt)("p",null,"Our algorithm ensures security as well as usability. With erroneous nodes in the consensus making no more than \u230a (N\u22121) / 3 \u230b , the functionality and stability of the system is guaranteed. In it, N = |\ud835\udc45| suggests the total number of nodes joined in the consensus making while R stands for the set of consensus nodes. Given F = \u230a (N\u22121) / 3 \u230b , f stands for the maximum number of erroneous nodes allowed in the system. In fact, the total ledger is maintained by bookkeeping nodes while ordinary nodes do not participate in the consensus making. This is to show the entire consensus making procedures."),(0,a.kt)("p",null,"All consensus nodes are required to maintain a state table to record current consensus status. The data set used for a consensus from its beginning to its end is called a View. If consensus cannot be reached within the current View, a View Change will be required. We identify each View with a number v, starting from 0 and it may increase till achieving the consensus."),(0,a.kt)("p",null,"We identify each consensus node with a number, starting from 0, the last node is numbered N \u2212 1. For each round of consensus making, a node will play speaker of the house while other nodes play congressmen. The speaker\u2019s number p will be determined by the following algorithm: Hypothetically the current block height is h, then \ud835\udc5d = (\u210e \u2212 \ud835\udc63) \ud835\udc5a\ud835\udc5c\ud835\udc51 N, p\u2019s value range will be  0 \u2264 \ud835\udc5d < N ."),(0,a.kt)("p",null,"A new block will be generated with each round of consensus, with at least N \u2212 F signatures from bookkeeping nodes. Upon the generation of a block, a new round of consensus making shall begin, resetting v=0."),(0,a.kt)("h3",{id:"general-procedures"},"General Procedures"),(0,a.kt)("p",null,(0,a.kt)("img",{src:n(71291).Z})),(0,a.kt)("p",null,"A round of consensus consists of 4 steps, as shown in the Figure above."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Speaker starts consensus by broadcasting a Prepare Request message,"),(0,a.kt)("li",{parentName:"ol"},"Delegates broadcast Prepare Response after receiving the Prepare Request message,"),(0,a.kt)("li",{parentName:"ol"},"Validators broadcast Commit after receiving enough Prepare Response messages,"),(0,a.kt)("li",{parentName:"ol"},"Validators produce & broadcast a new block after receiving enough Commit messages.")),(0,a.kt)("h3",{id:"view-change"},"View Change"),(0,a.kt)("p",null,"In case of the following scenarios, the Change View Request will be broadcasted attempting to replace speaker:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"The transaction verification fails"),(0,a.kt)("li",{parentName:"ul"},"Time is out while waiting for Prepare Request or Prepare Response")),(0,a.kt)("h3",{id:"recovery-mechanism"},"Recovery Mechanism"),(0,a.kt)("p",null,"When creating Change View Request, if there are not enough active consensus nodes (sum of nodes with Commit sent and fault nodes is greater than F), consensus nodes will broadcast Recovery Request message to update the local consensus context. Upon receiving Recovery Request, if certain conditions are met, a consensus node will generate and broadcast Recovery Message."),(0,a.kt)("h2",{id:"fault-tolerance-of-dbft20"},"Fault Tolerance of dBFT2.0"),(0,a.kt)("p",null,"A dBFT2.0 consensus system with ",(0,a.kt)("em",{parentName:"p"},"N")," validators can tolerate at most ",(0,a.kt)("em",{parentName:"p"},"F")," abnormal nodes. Each consensus phase (Commit, Change View, block generation, etc.) requires at least ",(0,a.kt)("em",{parentName:"p"},"M")," nodes to reach consensus. As long as the amount of normal validators is not less than ",(0,a.kt)("em",{parentName:"p"},"M"),", the consensus process will go on smoothly. For example, just 4 \u2212 \u230a (4\u22121) / 3 \u230b =3  normal validators required can keep alive a consensus system where ",(0,a.kt)("em",{parentName:"p"},"N")," = 4."),(0,a.kt)("h2",{id:"single-block-finality-of-dbft20"},"Single Block Finality of dBFT2.0"),(0,a.kt)("p",null,"Neo's dBFT 1.0 algorithm was susceptible to a single block fork in rare cases of network latency. dBFT2.0 fixes this problem, hence there is no possibility of forking since then. The mechanism is described as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"To generate a new block, it is required to collect Commit messages from at least M different validators for corresponding block proposal."),(0,a.kt)("li",{parentName:"ul"},"A validator will never change its view after broadcasting Commit message.")),(0,a.kt)("p",null,"Hence the success of block generation means:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"There are already at least M validators having signed the block proposal and broadcast Commit messages. Moreover, these validators won't change the view in current consensus round."),(0,a.kt)("li",{parentName:"ul"},"The rest of the validators are insufficient to produce another different block.")),(0,a.kt)("p",null,"Therefore, the finality of the new block can be guaranteed at a given height."))}h.isMDXComponent=!0},71291:function(e,t,n){t.Z=n.p+"assets/images/1-9b821fe380c5e8537c9235d520ba8a18.png"}}]);