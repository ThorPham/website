"use strict";(self.webpackChunkneo_dev_portal=self.webpackChunkneo_dev_portal||[]).push([[8329],{3905:function(t,n,e){e.d(n,{Zo:function(){return u},kt:function(){return d}});var a=e(67294);function r(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function i(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,a)}return e}function o(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?i(Object(e),!0).forEach((function(n){r(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):i(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function s(t,n){if(null==t)return{};var e,a,r=function(t,n){if(null==t)return{};var e,a,r={},i=Object.keys(t);for(a=0;a<i.length;a++)e=i[a],n.indexOf(e)>=0||(r[e]=t[e]);return r}(t,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(a=0;a<i.length;a++)e=i[a],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(r[e]=t[e])}return r}var c=a.createContext({}),l=function(t){var n=a.useContext(c),e=n;return t&&(e="function"==typeof t?t(n):o(o({},n),t)),e},u=function(t){var n=l(t.components);return a.createElement(c.Provider,{value:n},t.children)},p={inlineCode:"code",wrapper:function(t){var n=t.children;return a.createElement(a.Fragment,{},n)}},g=a.forwardRef((function(t,n){var e=t.components,r=t.mdxType,i=t.originalType,c=t.parentName,u=s(t,["components","mdxType","originalType","parentName"]),g=l(e),d=r,h=g["".concat(c,".").concat(d)]||g[d]||p[d]||i;return e?a.createElement(h,o(o({ref:n},u),{},{components:e})):a.createElement(h,o({ref:n},u))}));function d(t,n){var e=arguments,r=n&&n.mdxType;if("string"==typeof t||r){var i=e.length,o=new Array(i);o[0]=g;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=t,s.mdxType="string"==typeof t?t:r,o[1]=s;for(var l=2;l<i;l++)o[l]=e[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,e)}g.displayName="MDXCreateElement"},56004:function(t,n,e){e.r(n),e.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return g}});var a=e(87462),r=e(63366),i=(e(67294),e(3905)),o=["components"],s={},c="Transaction Construction",l={unversionedId:"n3/develop/tool/sdk/transaction",id:"n3/develop/tool/sdk/transaction",isDocsHomePage:!1,title:"Transaction Construction",description:"RpcClient encapsulates the transaction construction module, which allows you to construct transactions in Neo N3 with specific parameters and methods to personalize your functions. This document introduces the relevant methods.",source:"@site/docs/n3/develop/tool/sdk/transaction.md",sourceDirName:"n3/develop/tool/sdk",slug:"/n3/develop/tool/sdk/transaction",permalink:"/website/docs/n3/develop/tool/sdk/transaction",editUrl:"https://github.com/neo-project/neo-dev-portal/blob/master/docs/n3/develop/tool/sdk/transaction.md",tags:[],version:"current",lastUpdatedBy:"Apisit",frontMatter:{},sidebar:"docs",previous:{title:"RPC Invocation Methods",permalink:"/website/docs/n3/develop/tool/sdk/rpc"},next:{title:"Wallet Interfaces",permalink:"/website/docs/n3/develop/tool/sdk/wallet"}},u=[{value:"Transaction construction process",id:"transaction-construction-process",children:[]},{value:"Transaction Construction Examples",id:"transaction-construction-examples",children:[{value:"Constructing an NEP17 transfer transaction",id:"constructing-an-nep17-transfer-transaction",children:[]},{value:"Constructing a transaction to transfer to multi-signature account",id:"constructing-a-transaction-to-transfer-to-multi-signature-account",children:[]},{value:"Constructing a transaction to transfer from multi-signature account",id:"constructing-a-transaction-to-transfer-from-multi-signature-account",children:[]}]}],p={toc:u};function g(t){var n=t.components,e=(0,r.Z)(t,o);return(0,i.kt)("wrapper",(0,a.Z)({},p,e,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"transaction-construction"},"Transaction Construction"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"RpcClient")," encapsulates the transaction construction module, which allows you to construct transactions in Neo N3 with specific parameters and methods to personalize your functions. This document introduces the relevant methods."),(0,i.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"}," If you use SDK to construct a transaction that requires a signature, you need to ensure that the RpcClient obeject and the network it is connected to are configured the same way, or the transaction constructed by the SDK will not be validated in the blockchain. To do so, load Neo-CLI config.json when constructing the RpcClient object, for example:"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'RpcClient client = new RpcClient(new Uri("http://localhost:20332"), null, null, ProtocolSettings.Load("config.json"))')),(0,i.kt)("h2",{id:"transaction-construction-process"},"Transaction construction process"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Construct a transaction script to determine what functions the transaction will perform, such as a transfer transaction:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// construct the script, in this example, we will transfer 1 NEO to the receiver\nUInt160 scriptHash = NativeContract.NEO.Hash;\nbyte[] script = scriptHash.MakeScript("transfer", sender, receiver, 1\uff0c"data");\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Construct ",(0,i.kt)("inlineCode",{parentName:"p"},"TransactionManagerFactory")," with the parameter ",(0,i.kt)("inlineCode",{parentName:"p"},"RpcClient "),"; Construct ",(0,i.kt)("inlineCode",{parentName:"p"},"TransactionManager")," with the parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"Script")," and",(0,i.kt)("inlineCode",{parentName:"p"},"Signers"),":"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"TransactionManager txManager = await new TransactionManagerFactory(client)\n        .MakeTransactionAsync(script, signers).ConfigureAwait(false);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Add signature (single or multiple signatures) and use ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPair")," of the account as the parameter."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"single signature")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// add signature for the transaction with sendKey\ntxManager.AddSignature(sendKey);\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"multiple signatures")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// add multi-signatures for the transaction with sendKey\ntxManager.AddMultiSig(key1, 2, receiverKey.PublicKey, key2.PublicKey, key3.PublicKey);\ntxManager.AddMultiSig(key2, 2, receiverKey.PublicKey, key2.PublicKey, key3.PublicKey);\n")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"multi-signature contract"),(0,i.kt)("p",{parentName:"li"},"The nature of multi-signature comes from multi-signature contracts. You need to construct a multi-signature contract before you can obtain the multi-signature address and transfer assets. The following example uses 3 accounts to create a multi-signature contract which requires at least 2 account signatures for signing."))),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// create a multi-signature contract, which needs at least 2 of 3 KeyPairs to sign\nContract multiContract = Contract.CreateMultiSigContract(2, sendKey.PublicKey, key2.PublicKey, key3.PublicKey);\n// get the scripthash of the multi-signature contract\nUInt160 multiAccount = multiContract.Script.ToScriptHash();\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Verify signatures and add ",(0,i.kt)("inlineCode",{parentName:"p"},"Witness")," to the transaction body."),(0,i.kt)("p",{parentName:"li"},"If there are not enough signatures or fees an exception will be thrown."),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// sign the transaction with the added signatures\nTransaction tx = await txManager.SignAsync().ConfigureAwait(false);\n")))),(0,i.kt)("h2",{id:"transaction-construction-examples"},"Transaction Construction Examples"),(0,i.kt)("h3",{id:"constructing-an-nep17-transfer-transaction"},"Constructing an NEP17 transfer transaction"),(0,i.kt)("p",null,"The following example implements a function that transfers 1024 NEO from the sender account to the receiver account. You need to pay attention to the difference between the script and the signature in a transaction for constructing different transactions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using Neo;\nusing Neo.Network.P2P.Payloads;\nusing Neo.Network.RPC;\nusing Neo.SmartContract;\nusing Neo.SmartContract.Native;\nusing Neo.VM;\nusing Neo.Wallets;\nusing System;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestNep17Transfer().GetAwaiter().GetResult();\n            Console.Read();\n        }\n\n        private static async Task TestNep17Transfer()\n        {\n            // choose a neo node with rpc opened\n            RpcClient client = new RpcClient("http://127.0.0.1:10332");\n            // get the KeyPair of your account, which will pay the system and network fee\n            KeyPair sendKey = Utility.GetKeyPair("L53tg72Az8QhYUAyyqTQ3LaXMXBE3S9mJGGZVKHBryZxya7prwhZ");\n            UInt160 sender = Contract.CreateSignatureContract(sendKey.PublicKey).ScriptHash;\n\n            // add Signers, which is a collection of scripthashs that need to be signed\n            Signer[] cosigners = new[] { new Signer { Scopes = WitnessScope.CalledByEntry, Account = sender } };\n\n            // get the scripthash of the account you want to transfer to\n            UInt160 receiver = Utility.GetScriptHash("NirHUAteaMr6CqWuAAMaEUScPcS3FDKebM");\n\n            // construct the script, in this example, we will transfer 1024 NEO to receiver\n            UInt160 scriptHash = NativeContract.NEO.Hash;\n            byte[] script = scriptHash.MakeScript("transfer", sender, receiver, 1024);\n\n            // initialize the TransactionManagerFactory with rpc client and magic\n            // fill in the TransactionManager with the script and cosigners\n            TransactionManager txManager = await new TransactionManagerFactory(client, 5195086)\n                .MakeTransactionAsync(script, cosigners).ConfigureAwait(false);\n            // add signature and sign transaction with the added signature\n            Transaction tx = await txManager.AddSignature(sendKey).SignAsync().ConfigureAwait(false);\n\n            // broadcasts the transaction over the Neo network.\n            await client.SendRawTransactionAsync(tx).ConfigureAwait(false);\n            Console.WriteLine($"Transaction {tx.Hash.ToString()} is broadcasted!");\n\n            // print a message after the transaction is on chain\n            WalletAPI neoAPI = new WalletAPI(client);\n            await neoAPI.WaitTransactionAsync(tx)\n               .ContinueWith(async (p) => Console.WriteLine($"Transaction vm state is {(await p).VMState}"));\n        }\n    }\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"WalletAPI")," encapsulates the above process, so you can simplify the NEP17 transfer as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using Neo;\nusing Neo.Network.P2P.Payloads;\nusing Neo.Network.RPC;\nusing Neo.SmartContract;\nusing Neo.SmartContract.Native;\nusing Neo.VM;\nusing Neo.Wallets;\nusing System;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestNep17Transfer().GetAwaiter().GetResult();\n            Console.Read();\n        }\n\n        private static async Task TestNep17Transfer()\n        {\n            // choose a neo node with rpc opened\n            RpcClient client = new RpcClient("http://127.0.0.1:10332");\n            // get the KeyPair of your account, which will pay the system and network fee\n            KeyPair sendKey = Utility.GetKeyPair("L53tg72Az8QhYUAyyqTQ3LaXMXBE3S9mJGGZVKHBryZxya7prwhZ");\n\n            // get the scripthash of the account you want to transfer to\n            UInt160 receiver = Utility.GetScriptHash("NirHUAteaMr6CqWuAAMaEUScPcS3FDKebM");\n\n            // use WalletAPI to create and send the transfer transaction\n            WalletAPI walletAPI = new WalletAPI(client);\n            Transaction tx = await walletAPI.TransferAsync(NativeContract.NEO.Hash, sendKey, receiver, 1024).ConfigureAwait(false);\n\n            // print a message after the transaction is on chain\n            WalletAPI neoAPI = new WalletAPI(client);\n            await neoAPI.WaitTransactionAsync(tx)\n               .ContinueWith(async (p) => Console.WriteLine($"Transaction vm state is {(await p).VMState}"));\n        }\n    }\n}\n')),(0,i.kt)("h3",{id:"constructing-a-transaction-to-transfer-to-multi-signature-account"},"Constructing a transaction to transfer to multi-signature account"),(0,i.kt)("p",null,"The following example implements a function that transfers 10 GAS to a multi-signature account. The scripthash of a multi-signature account is obtained from the scripthash of the multi-signature contract. As the sender is a normal account, the process of adding a signature is the same as last example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using Neo;\nusing Neo.Network.P2P.Payloads;\nusing Neo.Network.RPC;\nusing Neo.SmartContract;\nusing Neo.SmartContract.Native;\nusing Neo.VM;\nusing Neo.Wallets;\nusing System;\nusing Utility = Neo.Network.RPC.Utility;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestToMultiTransfer().GetAwaiter().GetResult();\n            Console.Read();\n        }\n\n        private static async Task TestToMultiTransfer()\n        {\n            // choose a neo node with rpc opened\n            RpcClient client = new RpcClient("http://127.0.0.1:10332");\n            // get the KeyPair of your account, which will pay the system and network fee\n            KeyPair sendKey = Utility.GetKeyPair("L53tg72Az8QhYUAyyqTQ3LaXMXBE3S9mJGGZVKHBryZxya7prwhZ");\n            UInt160 sender = Contract.CreateSignatureContract(sendKey.PublicKey).ScriptHash;\n\n            // get the KeyPair of your accounts\n            KeyPair key2 = Utility.GetKeyPair("L1bQBbZWnKbPkpHM3jXWD3E5NwK7nui2eWHYXVZPy3t8jSFF1Qj3");\n            KeyPair key3 = Utility.GetKeyPair("KwrJfYyc7KWfZG5h97SYfcCQyW4jRw1njmHo48kZhZmuQWeTtUHM");\n\n            // create multi-signatures contract, this contract needs at least 2 of 3 KeyPairs to sign\n            Contract multiContract = Contract.CreateMultiSigContract(2, sendKey.PublicKey, key2.PublicKey, key3.PublicKey);\n            // get the scripthash of the multi-signature Contract\n            UInt160 multiAccount = multiContract.Script.ToScriptHash();\n\n            // construct the script, in this example, we will transfer 1024 GAS to multi-sign account\n            // in contract parameter, the amount type is BigInteger, so we need to muliply the contract factor\n            UInt160 scriptHash = NativeContract.GAS.Hash;\n            byte[] script = scriptHash.MakeScript("transfer", sender, multiAccount, 1024 * NativeContract.GAS.Factor);\n\n            // add Signers, which is a collection of scripthashs that need to be signed\n            Signer[] cosigners = new[] { new Signer { Scopes = WitnessScope.CalledByEntry, Account = sender } };\n\n            // initialize the TransactionManager with rpc client and magic\n            // fill the script and cosigners\n            TransactionManager txManager = await new TransactionManagerFactory(client, 5195086)\n                .MakeTransactionAsync(script, cosigners).ConfigureAwait(false);\n            // add signature and sign transaction with the added signature\n            Transaction tx = await txManager.AddSignature(sendKey).SignAsync().ConfigureAwait(false);\n\n            // broadcasts the transaction over the Neo network.\n            await client.SendRawTransactionAsync(tx).ConfigureAwait(false);\n            Console.WriteLine($"Transaction {tx.Hash.ToString()} is broadcasted!");\n\n            // print a message after the transaction is on chain\n            WalletAPI neoAPI = new WalletAPI(client);\n            await neoAPI.WaitTransactionAsync(tx)\n               .ContinueWith(async (p) => Console.WriteLine($"Transaction vm state is {(await p).VMState}"));\n        }\n    }\n}\n')),(0,i.kt)("h3",{id:"constructing-a-transaction-to-transfer-from-multi-signature-account"},"Constructing a transaction to transfer from multi-signature account"),(0,i.kt)("p",null,"The following example implements a function that transfers 1024 GAS from a multi-signature account. The scripthash of the multi-signature account is obtained from the scripthash of the multi-signature contract. To transfer assets from a multi-signature account, you need to add signatures required by the multi-signature contract."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using Neo;\nusing Neo.Network.P2P.Payloads;\nusing Neo.Network.RPC;\nusing Neo.SmartContract;\nusing Neo.SmartContract.Native;\nusing Neo.VM;\nusing Neo.Wallets;\nusing System;\nusing Utility = Neo.Network.RPC.Utility;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            TestFromMultiTransfer().GetAwaiter().GetResult();\n            Console.Read();\n        }\n\n        private static async Task TestFromMultiTransfer()\n        {\n            // choose a neo node with rpc opened\n            RpcClient client = new RpcClient("http://127.0.0.1:10332");\n\n            // get the KeyPair of your account\n            KeyPair receiverKey = Utility.GetKeyPair("L53tg72Az8QhYUAyyqTQ3LaXMXBE3S9mJGGZVKHBryZxya7prwhZ");\n            KeyPair key2 = Utility.GetKeyPair("L1bQBbZWnKbPkpHM3jXWD3E5NwK7nui2eWHYXVZPy3t8jSFF1Qj3");\n            KeyPair key3 = Utility.GetKeyPair("KwrJfYyc7KWfZG5h97SYfcCQyW4jRw1njmHo48kZhZmuQWeTtUHM");\n\n            // create multi-signature contract, this contract needs at least 2 of 3 KeyPairs to sign\n            Contract multiContract = Contract.CreateMultiSigContract(2, receiverKey.PublicKey, key2.PublicKey, key3.PublicKey);\n            // get the scripthash of the multi-signature Contract\n            UInt160 multiAccount = multiContract.Script.ToScriptHash();\n\n            UInt160 receiver = Contract.CreateSignatureContract(receiverKey.PublicKey).ScriptHash;\n\n            // construct the script, in this example, we will transfer 1024 GAS to multi-sign account\n            // in contract parameter, the amount type is BigInteger, so we need to muliply the contract factor\n            UInt160 scriptHash = NativeContract.GAS.Hash;\n            byte[] script = scriptHash.MakeScript("transfer", multiAccount, receiver, 1024 * NativeContract.GAS.Factor);\n\n            // add Signers, which is a collection of scripthashs that need to be signed\n            Signer[] cosigners = new[] { new Signer { Scopes = WitnessScope.CalledByEntry, Account = multiAccount } };\n\n            // initialize the TransactionManager with rpc client and magic\n            // fill the script and cosigners\n            TransactionManager txManager = await new TransactionManagerFactory(client, 5195086)\n                .MakeTransactionAsync(script, cosigners).ConfigureAwait(false);\n            // add signature and sign transaction with the added signature\n            Transaction tx = await txManager.AddMultiSig(new KeyPair[]{receiverKey, key2}, 2, receiverKey.PublicKey, key2.PublicKey, key3.PublicKey)\n                .SignAsync().ConfigureAwait(false);\n\n            // broadcasts the transaction over the Neo network.\n            await client.SendRawTransactionAsync(tx).ConfigureAwait(false);\n            Console.WriteLine($"Transaction {tx.Hash.ToString()} is broadcasted!");\n\n            // print a message after the transaction is on chain\n            WalletAPI neoAPI = new WalletAPI(client);\n            await neoAPI.WaitTransactionAsync(tx)\n               .ContinueWith(async (p) => Console.WriteLine($"Transaction vm state is {(await p).VMState}"));\n        }\n    }\n}\n')))}g.isMDXComponent=!0}}]);