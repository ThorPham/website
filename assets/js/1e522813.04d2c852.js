"use strict";(self.webpackChunkneo_dev_portal=self.webpackChunkneo_dev_portal||[]).push([[3190],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return u}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),h=d(n),u=o,m=h["".concat(s,".").concat(u)]||h[u]||p[u]||i;return n?a.createElement(m,r(r({ref:t},c),{},{components:n})):a.createElement(m,r({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var d=2;d<i;d++)r[d]=n[d];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},87750:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return d},assets:function(){return c},toc:function(){return p},default:function(){return u}});var a=n(87462),o=n(63366),i=(n(67294),n(3905)),r=["components"],l={title:"Neo3-boa - Writing a fungible token contract using Python",description:"This tutorial provides step-by-step instructions for creating a fungible token contract on the Neo  blockchain using Python and Neo3-boa. It does so by demonstrating how to comply with the NEP-17 standard.",author:"coz.io",tags:["PYTHON","NEO3BOA","SMART CONTRACT","NEP-17"],skill:"BEGINNER",image:"./assets/boa-logo.png",sidebar:!0},s=void 0,d={permalink:"/website/tutorials/2023/07/05/neo3-boa-writing-a-fungible-token-contract-using-python",source:"@site/tutorials/2023-07-05-neo3-boa-writing-a-fungible-token-contract-using-python/index.md",title:"Neo3-boa - Writing a fungible token contract using Python",description:"This tutorial provides step-by-step instructions for creating a fungible token contract on the Neo  blockchain using Python and Neo3-boa. It does so by demonstrating how to comply with the NEP-17 standard.",date:"2023-07-05T00:00:00.000Z",formattedDate:"July 5, 2023",tags:[{label:"PYTHON",permalink:"/website/tutorials/tags/python"},{label:"NEO3BOA",permalink:"/website/tutorials/tags/neo-3-boa"},{label:"SMART CONTRACT",permalink:"/website/tutorials/tags/smart-contract"},{label:"NEP-17",permalink:"/website/tutorials/tags/nep-17"}],readingTime:9.725,truncated:!1,authors:[{name:"coz.io"}],nextItem:{title:"neow3j - Implementing a NEP-17 Smart Contract in Java",permalink:"/website/tutorials/2023/05/16/neow3j-nep17"}},c={image:n(40603).Z,authorsImageUrls:[void 0]},p=[{value:"0. Introduction",id:"0-introduction",children:[{value:"What is the NEP-17 Standard?",id:"what-is-the-nep-17-standard",children:[]},{value:"Why follow a standard?",id:"why-follow-a-standard",children:[]}]},{value:"1. Prerequisites",id:"1-prerequisites",children:[]},{value:"2. Create a virtual environment using VS Code and install Neo3-boa",id:"2-create-a-virtual-environment-using-vs-code-and-install-neo3-boa",children:[]},{value:"3. Create the Coin contract file",id:"3-create-the-coin-contract-file",children:[]},{value:"4. Compiling the contract",id:"4-compiling-the-contract",children:[]},{value:"5. Running the contract using the Neo Blockchain Toolkit",id:"5-running-the-contract-using-the-neo-blockchain-toolkit",children:[]},{value:"6. Contract Initialization",id:"6-contract-initialization",children:[{value:"_deploy",id:"_deploy",children:[]}]},{value:"7. NEP-17 Methods",id:"7-nep-17-methods",children:[{value:"symbol",id:"symbol",children:[]},{value:"decimals",id:"decimals",children:[]},{value:"totalSupply",id:"totalsupply",children:[]},{value:"balanceOf",id:"balanceof",children:[]},{value:"transfer",id:"transfer",children:[]}]},{value:"8. NEP-17 Event",id:"8-nep-17-event",children:[]},{value:"9. NEP-17 Callbacks",id:"9-nep-17-callbacks",children:[]},{value:"10. Manifest Metadata",id:"10-manifest-metadata",children:[]},{value:"11. Other examples",id:"11-other-examples",children:[]}],h={toc:p};function u(e){var t=e.components,l=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},h,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"0-introduction"},"0. Introduction"),(0,i.kt)("p",null,"This tutorial will show you how to create a fungible token using ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CityOfZion/neo3-boa"},"Neo3-boa"),", the\ntool to compile Python scripts into NeoVM compatible code. The token will be compliant with the NEP-17 standard."),(0,i.kt)("h3",{id:"what-is-the-nep-17-standard"},"What is the NEP-17 Standard?"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/neo-project/proposals/blob/master/nep-17.mediawiki"},"NEP-17 standard")," defines a set of rules that\na token contract must follow to be considered a valid fungible token on the Neo blockchain.\nThe standard defines methods, events and callbacks that the contract must implement. The NEP-17 standard is the\nequivalent of the ERC-20 standard in Ethereum."),(0,i.kt)("h3",{id:"why-follow-a-standard"},"Why follow a standard?"),(0,i.kt)("p",null,"When a contract follows a standard, other contracts and applications can interact with it without having to know the\nimplementation details. This allows other developers to easily create interoperable contracts and applications."),(0,i.kt)("h2",{id:"1-prerequisites"},"1. Prerequisites"),(0,i.kt)("p",null,"This tutorial assumes that you have ",(0,i.kt)("a",{parentName:"p",href:"https://www.python.org/"},"Python 3.7")," or any higher version,\n",(0,i.kt)("a",{parentName:"p",href:"https://code.visualstudio.com/"},"Visual Studio Code"),", the\n",(0,i.kt)("a",{parentName:"p",href:"https://marketplace.visualstudio.com/items?itemName=ms-python.python"},"Python VS Code extension")," and the\n",(0,i.kt)("a",{parentName:"p",href:"https://marketplace.visualstudio.com/items?itemName=ngd-seattle.neo-blockchain-toolkit"},"Neo Blockchain Toolkit VS Code extension"),"\ninstalled and properly configured."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"To properly configure Neo Blockchain Toolkit you should follow their ",(0,i.kt)("a",{parentName:"p",href:"https://developers.neo.org/tutorials/2021/05/27/getting-started-with-the-neo-blockchain-toolkit"},"tutorial"),".")),(0,i.kt)("h2",{id:"2-create-a-virtual-environment-using-vs-code-and-install-neo3-boa"},"2. Create a virtual environment using VS Code and install Neo3-boa"),(0,i.kt)("p",null,"Create a new folder for your project and open it in VS Code, then create a file named ",(0,i.kt)("inlineCode",{parentName:"p"},"requirements.txt")," and write\n",(0,i.kt)("inlineCode",{parentName:"p"},"neo3-boa==1.0.0")," inside it."),(0,i.kt)("p",null,"Press ",(0,i.kt)("inlineCode",{parentName:"p"},"Ctrl+Shift+P")," to open the Command Palette and type ",(0,i.kt)("inlineCode",{parentName:"p"},"Python: Create Environment"),", select ",(0,i.kt)("inlineCode",{parentName:"p"},"Venv"),", your Python\nversion, select the ",(0,i.kt)("inlineCode",{parentName:"p"},"requirements.txt")," file, and press ",(0,i.kt)("inlineCode",{parentName:"p"},"Ok"),", so that the virtual environment can be created."),(0,i.kt)("p",null,"If you have a Python file open, you can check the lower right corner of VS Code to verify that the virtual environment\nis active, and it's using Python 3."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"Venv active on Python file",src:n(78458).Z})),(0,i.kt)("h2",{id:"3-create-the-coin-contract-file"},"3. Create the Coin contract file"),(0,i.kt)("p",null,"Create a new file called ",(0,i.kt)("inlineCode",{parentName:"p"},"coin.py")," and add the following method to indicate that a hundred million tokens will exist in\nthe contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from boa3.builtin.compile_time import public\n\n@public(name='totalSupply', safe=True)\ndef total_supply() -> int:\n    return 10 ** 8\n")),(0,i.kt)("h2",{id:"4-compiling-the-contract"},"4. Compiling the contract"),(0,i.kt)("p",null,"Open the VS Code terminal and run the following command to compile the contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bash"},"neo3-boa compile coin.py --debug\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Note: if you are using a powershell terminal you might get an error before executing the command above stating that\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"Activate.ps1 cannot be loaded because running scripts is disabled on this system"),", you can just use a cmd\nterminal instead by clicking on the ",(0,i.kt)("strong",{parentName:"p"},"\u2304")," icon on right side of the ",(0,i.kt)("strong",{parentName:"p"},"+")," symbol on the terminal tab and selecting\n",(0,i.kt)("inlineCode",{parentName:"p"},"Command Prompt"),". If everything is alright you should see ",(0,i.kt)("inlineCode",{parentName:"p"},"(.venv)")," at the beginning of the terminal line, and then\nyou can execute the code above.\n",(0,i.kt)("img",{alt:"Activating CMD on Terminal",src:n(50248).Z}))),(0,i.kt)("p",null,"Be sure to include the ",(0,i.kt)("inlineCode",{parentName:"p"},"--debug")," flag to generate the debug information required by the Neo Blockchain Toolkit."),(0,i.kt)("p",null,"If the compilation is successful, you should see 3 new files:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"coin.nef"),": The contract binary file (bytecode);"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"coin.manifest.json"),": The contract manifest file. This file is required to deploy the contract and is automatically\ngenerated by the compiler alongside the nef."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"coin.nefdbgnfo"),": The debug information file. This file is required by the Neo Blockchain Toolkit to debug the contract.")),(0,i.kt)("h2",{id:"5-running-the-contract-using-the-neo-blockchain-toolkit"},"5. Running the contract using the Neo Blockchain Toolkit"),(0,i.kt)("p",null,"Click on the ",(0,i.kt)("inlineCode",{parentName:"p"},".nef")," or ",(0,i.kt)("inlineCode",{parentName:"p"},".manifest.json")," generated file and press ",(0,i.kt)("inlineCode",{parentName:"p"},"Ctrl+Shift+D")," to open the Run and Debug panel.\nClick on ",(0,i.kt)("inlineCode",{parentName:"p"},"create a launch.json file")," and select ",(0,i.kt)("inlineCode",{parentName:"p"},"Neo Contract")," as the environment."),(0,i.kt)("p",null,"This will generate a ",(0,i.kt)("inlineCode",{parentName:"p"},".vscode/launch.json")," file inside the project folder. Open the file and replace the ",(0,i.kt)("inlineCode",{parentName:"p"},"operation"),"\nfield value with ",(0,i.kt)("inlineCode",{parentName:"p"},"totalSupply"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-json"},'...\n"invocation": {\n    "operation": "totalSupply",\n    "args": []\n}\n...\n')),(0,i.kt)("p",null,"Next, press ",(0,i.kt)("inlineCode",{parentName:"p"},"F5")," to start debugging. The Neo Blockchain Toolkit will automatically deploy the contract and invoke the\n",(0,i.kt)("inlineCode",{parentName:"p"},"totalSupply")," method in a test environment."),(0,i.kt)("p",null,"Debugging the ",(0,i.kt)("inlineCode",{parentName:"p"},"totalSupply")," method will not be very useful, but it's a good way to test if your environment is working\nproperly. After debugging, you should get a message on the debug console showing the GAS consumed and the return value of the method."),(0,i.kt)("h2",{id:"6-contract-initialization"},"6. Contract Initialization"),(0,i.kt)("p",null,"Neo has some methods that are automatically called by the Virtual Machine, for example, there is the ",(0,i.kt)("inlineCode",{parentName:"p"},"_deploy")," method\nthat is called whenever a contract is deployed or updated, and is often used in all kinds of smart contracts. This can\nbe useful to set up some information on the storage."),(0,i.kt)("h3",{id:"_deploy"},"_deploy"),(0,i.kt)("p",null,"We will be using this method to initialize the contract storage, giving all tokens to the one who deployed the smart\ncontract. To do so, we will be using the ",(0,i.kt)("inlineCode",{parentName:"p"},"runtime.script_container")," to get the script hash of the sender."),(0,i.kt)("p",null,"Then, save the sender as the owner of the whole total supply on the storage with the ",(0,i.kt)("inlineCode",{parentName:"p"},"storage.put")," method. Our strategy\nis to have the owner as the key and the quantity of tokens they own as the value of the storage."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# update coin.py adding the following code:\nfrom boa3.builtin.contract import Nep17TransferEvent\nfrom boa3.builtin.interop import runtime, storage\nfrom boa3.builtin.interop.blockchain import Transaction\n\n\n@public\ndef _deploy(data: Any, update: bool):\n    # if the contract is being deployed for the first time, add all tokens to the contract deployer\n    if not update:\n        container: Transaction = runtime.script_container\n        storage.put(container.sender, total_supply())\n\n        # trigger the Transfer event to notify that the tokens were minted, check out the `NEP-17 Event` section below for more details\n        Nep17TransferEvent(None, container.sender, total_supply())\n")),(0,i.kt)("p",null,"Methods that start with an underscore are not callable by the user. In this example, the ",(0,i.kt)("inlineCode",{parentName:"p"},"_deploy")," method is called\nautomatically when the contract is deployed."),(0,i.kt)("h2",{id:"7-nep-17-methods"},"7. NEP-17 Methods"),(0,i.kt)("p",null,"The NEP-17 standard defines 5 mandatory methods that a token contract must implement:"),(0,i.kt)("h3",{id:"symbol"},"symbol"),(0,i.kt)("p",null,"Returns the token symbol. In this example, we will return the string ",(0,i.kt)("inlineCode",{parentName:"p"},"COIN"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},'# update coin.py adding the following code:\n\n@public(safe=True)\ndef symbol() -> str:\n    return "COIN"\n')),(0,i.kt)("p",null,"When writting methods that will be used by other contracts or users, you need to use the ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," decorator.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"safe")," parameter indicates that when calling the method it won't change the contract storage and can be safely\ncalled by other contracts or users."),(0,i.kt)("h3",{id:"decimals"},"decimals"),(0,i.kt)("p",null,"Returns the number of decimals used by the token.\nThis is used to provide decimal precision when displaying token balances because Neo doesn't support floating types as\nthey are often unreliable. In this example, we will return ",(0,i.kt)("strong",{parentName:"p"},"2"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# update coin.py adding the following code:\n\n@public(safe=True)\ndef decimals() -> int:\n    return 2\n")),(0,i.kt)("h3",{id:"totalsupply"},"totalSupply"),(0,i.kt)("p",null,"Returns the total supply of the token. We already implemented this method before, but, since we just defined that there will be\n2 decimals, we need to multiply the supply by 10 ** 2."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# update coin.py adding the following code:\n\n@public(name='totalSupply', safe=True)\ndef total_supply() -> int:\n    return (10 ** 8) * 10 ** decimals()\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter is used to define how this method will be called. Since Neo's first supported languages were C#, VB.Net, F#,\nJava, and Kotlin, the naming convention of the Neo standards methods is not snake_case. However, Neo3-boa allows you to write a\nmore pythonic code with snake_case methods as long as you add the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," parameter to the ",(0,i.kt)("inlineCode",{parentName:"p"},"public")," decorator when necessary."),(0,i.kt)("h3",{id:"balanceof"},"balanceOf"),(0,i.kt)("p",null,"Returns the balance of a token for a specific address. Every token should be stored and linked to an address in the\ncontract storage, and to access the storage we will be using the ",(0,i.kt)("inlineCode",{parentName:"p"},"storage.get")," method."),(0,i.kt)("p",null,"In this smart contract, we made it so that the key to accessing the number of tokens an address has is just the script hash\nof the address (represented by the ",(0,i.kt)("inlineCode",{parentName:"p"},"UInt160")," type)."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"storage.get")," method returns a ",(0,i.kt)("inlineCode",{parentName:"p"},"bytes")," value, so we need to convert it to an ",(0,i.kt)("inlineCode",{parentName:"p"},"int")," before returning it."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# update coin.py adding the following code:\nfrom boa3.builtin.type import UInt160, helper as type_helper\n\n@public(name='balanceOf', safe=True)\ndef balance_of(account: UInt160) -> int:\n    assert len(account) == 20   # NEP-17 requires the address to be 20 bytes long\n\n    amount_in_bytes = storage.get(account)\n    return type_helper.to_int(amount_in_bytes)\n")),(0,i.kt)("h3",{id:"transfer"},"transfer"),(0,i.kt)("p",null,"Transfers a number of tokens from the sender to the specified address, passing an optional data parameter."),(0,i.kt)("p",null,"We won't be using the data parameter in this example, but it's required by the NEP-17 standard. This method has a lot\nof peculiarities detailed in the comments in the code below."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# update coin.py adding the following code:\n\nfrom typing import Any\nfrom boa3.builtin.interop import blockchain, contract\n\n@public\ndef transfer(from_address: UInt160, to_address: UInt160, amount: int, data: Any) -> bool:\n    # NEP-17 requires the address to be 20 bytes long\n    assert len(from_address) == 20   \n    assert len(to_address) == 20\n    # it also requires the amount to be greater than or equal to 0\n    assert amount >= 0\n\n    tokens_sender = balance_of(from_address)\n    tokens_receiver = balance_of(to_address)\n\n    # to transfer tokens, the sender must be authenticated. \n    # We will use the `check_witness` method to verify that the sender is the owner of the tokens.\n    if not runtime.check_witness(from_address):\n        return False\n\n    if tokens_sender < amount:\n        return False\n\n    # if `amount` is 0 or the sender is also the receiver, there is no need to change the storage\n    if amount != 0 and from_address != to_address:\n        # use the `storage.put` method to change the storage\n        storage.put(from_address, type_helper.to_bytes(tokens_sender - amount))\n        storage.put(to_address, type_helper.to_bytes(tokens_receiver + amount))\n    \n    # if the method succeeds, it must fire the Transfer event (more details in the next section)\n    Nep17TransferEvent(from_address, to_address, amount)\n    # if the to_address is a smart contract, it must call the onNEP17Payment\n    if blockchain.get_contract(to_address) is not None:\n        contract.call_contract(to_address, 'onNEP17Payment', [from_address, amount, data])\n\n    return True\n")),(0,i.kt)("p",null,"Since the ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," method changes values on the storage, it can not be flagged as ",(0,i.kt)("inlineCode",{parentName:"p"},"safe"),"."),(0,i.kt)("h2",{id:"8-nep-17-event"},"8. NEP-17 Event"),(0,i.kt)("p",null,"The NEP-17 standard defines a single event called ",(0,i.kt)("inlineCode",{parentName:"p"},"Transfer")," that must be triggered when a transfer occurs.\nYou can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"Nep17TransferEvent")," from Neo3-boa or create your own event with ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateNewEvent"),"."),(0,i.kt)("p",null,"In this example, we use this event twice: when minting all the tokens at the deploy and whenever a transfer operation occurs."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# update coin.py adding the following code:\nfrom boa3.builtin.compile_time import CreateNewEvent\n\non_nep17_transfer = CreateNewEvent(\n    [\n        ('from', Union[UInt160, None]),\n        ('to', Union[UInt160, None]),\n        ('amount', int),\n    ],\n    'Transfer'\n)\n\n# to trigger the event, just call it by passing the parameters\n# using the already implemented Event:\nNep17TransferEvent(from_address, to_address, amount)\n# using the newly created Event:\non_nep17_transfer(from_address, to_address, amount)\n")),(0,i.kt)("h2",{id:"9-nep-17-callbacks"},"9. NEP-17 Callbacks"),(0,i.kt)("p",null,"The NEP-17 standard defines a single callback called ",(0,i.kt)("inlineCode",{parentName:"p"},"onNEP17Payment")," that must be called if the recipient is a contract.\nThis callback is used to notify the recipient that it has received tokens. It's up to the recipient to implement this\ncallback. The recipient can reject the transfer by raising an exception."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"# update coin.py adding the following code:\nfrom boa3.builtin.contract import abort\n\n@public(name='onNEP17Payment')\ndef on_nep17_payment(from_address: UInt160, amount: int, data: Any):\n    abort()     # in this example, the smart contract is rejecting all transfers made to it\n")),(0,i.kt)("h2",{id:"10-manifest-metadata"},"10. Manifest Metadata"),(0,i.kt)("p",null,"Neo3-boa allows you to define the contract metadata using the ",(0,i.kt)("inlineCode",{parentName:"p"},"metadata")," decorator. This information is used to generate\nthe contract manifest file."),(0,i.kt)("p",null,"In our example, we will define the contract name and the supported standards, but you can add any information you want\nto. We are also adding permissions to allow our contract to call the ",(0,i.kt)("inlineCode",{parentName:"p"},"onNEP17Payment")," method. The compiler automatically\ndoes this step, but it's a good practice to define the permissions in the contract code."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"from boa3.builtin.compile_time import metadata, NeoMetadata\n\n@metadata\ndef manifest_metadata() -> NeoMetadata:\n    meta = NeoMetadata()\n    meta.name = 'Coin Contract'\n    meta.supported_standards = ['NEP-17']\n    meta.add_permission(methods=['onNEP17Payment'])\n    return meta\n")),(0,i.kt)("h2",{id:"11-other-examples"},"11. Other examples"),(0,i.kt)("p",null,"Check out this ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CityOfZion/neo3-boa/blob/v1.0.0/boa3_test/examples/simple_nep17.py"},"simple NEP-17"),"\nexample to see a smart contract that is as simple as the one in this example, but is more cohesive and uses some more\nfeatures in its implementation."),(0,i.kt)("p",null,"Also, check out this ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/CityOfZion/neo3-boa/blob/v1.0.0/boa3_test/examples/nep17.py"},"more complex NEP-17"),"\nexample to examine a smart contract that can also mint and burn tokens."))}u.isMDXComponent=!0},40603:function(e,t,n){t.Z=n.p+"assets/images/boa-logo-8493b25150447cf1dd2364131056e934.png"},50248:function(e,t,n){t.Z=n.p+"assets/images/terminal-cmd-3355599f9c0a75ce564ebe07f169762a.png"},78458:function(e,t,n){t.Z=n.p+"assets/images/venv-active-2631ef052e1e52804302d713079df4dc.png"}}]);