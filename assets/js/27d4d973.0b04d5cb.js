"use strict";(self.webpackChunkneo_dev_portal=self.webpackChunkneo_dev_portal||[]).push([[6854],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,s=e.parentName,p=c(e,["components","mdxType","originalType","parentName"]),u=l(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||i;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,r=new Array(i);r[0]=u;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:o,r[1]=c;for(var l=2;l<i;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},69681:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return c},contentTitle:function(){return s},metadata:function(){return l},toc:function(){return p},default:function(){return u}});var a=n(87462),o=n(63366),i=(n(67294),n(3905)),r=["components"],c={},s="Deploying and Invoking Contracts",l={unversionedId:"n3/develop/tool/sdk/contract",id:"n3/develop/tool/sdk/contract",isDocsHomePage:!1,title:"Deploying and Invoking Contracts",description:"In Neo N3 most of the functions are provided by contracts. ScriptHash is the unique identifier of the contract, and it is usually a necessary parameter for invoking contracts.",source:"@site/docs/n3/develop/tool/sdk/contract.md",sourceDirName:"n3/develop/tool/sdk",slug:"/n3/develop/tool/sdk/contract",permalink:"/website/docs/n3/develop/tool/sdk/contract",editUrl:"https://github.com/neo-project/neo-dev-portal/blob/master/docs/n3/develop/tool/sdk/contract.md",tags:[],version:"current",lastUpdatedBy:"Apisit",frontMatter:{},sidebar:"docs",previous:{title:"Invoking Smart Contracts",permalink:"/website/docs/n3/develop/deploy/invoke"},next:{title:"About RpcClient",permalink:"/website/docs/n3/develop/tool/sdk/introduction"}},p=[{value:"Contract deployment",id:"contract-deployment",children:[]},{value:"Contract invocation simulation",id:"contract-invocation-simulation",children:[]},{value:"Contract invocation (on-chain transactions)",id:"contract-invocation-on-chain-transactions",children:[]},{value:"NEP-17 Contracts",id:"nep-17-contracts",children:[]}],d={toc:p};function u(e){var t=e.components,n=(0,o.Z)(e,r);return(0,i.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"deploying-and-invoking-contracts"},"Deploying and Invoking Contracts"),(0,i.kt)("p",null,"In Neo N3 most of the functions are provided by contracts. ScriptHash is the unique identifier of the contract, and it is usually a necessary parameter for invoking contracts."),(0,i.kt)("p",null,"This document introduces the following SDK features:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The construction method of contract deployment transaction"),(0,i.kt)("li",{parentName:"ul"},"Invoking methods in the contract under read-only mode"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Nep17API")," class that encapsulates the methods for invoking NEP17 contracts")),(0,i.kt)("h2",{id:"contract-deployment"},"Contract deployment"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ContractClient")," provides the method, ",(0,i.kt)("inlineCode",{parentName:"p"},"CreateDeployContractTxAsync"),", to construct deployment transactions of the contract. The parameters are contract scripts, manifests, and account key pairs for payment of system and network fees, where contract scripts and manifests are available from the compilation. There must be sufficient GAS in the sender account."),(0,i.kt)("p",null,"Read the nef and manifest.json files of the contract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// read nefFile & manifestFile\nNefFile nefFile;\nusing (var stream = new BinaryReader(File.OpenRead(nefFilePath), Encoding.UTF8, false))\n{\n    nefFile = stream.ReadSerializable<NefFile>();\n}\n\nContractManifest manifest = ContractManifest.Parse(File.ReadAllBytes(manifestFilePath));\n")),(0,i.kt)("p",null,"Construct a contract deployment transaction:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// create the deploy contract transaction\nTransaction transaction = await contractClient.CreateDeployContractTxAsync(nefFile.ToArray(), manifest, senderKeyPair);\n")),(0,i.kt)("p",null,"After the transaction is constructed, you need to broadcast it on the blockchain:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// Broadcast the transaction over the Neo network\nawait client.SendRawTransactionAsync(transaction);\nConsole.WriteLine($"Transaction {transaction.Hash.ToString()} is broadcasted!");\n')),(0,i.kt)("p",null,"After the transaction is added to the blockchain you can get the transaction execution status to check if the contract is deployed successfully:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// print a message after the transaction is on chain\nWalletAPI neoAPI = new WalletAPI(client);\nawait neoAPI.WaitTransactionAsync(transaction)\n    .ContinueWith(async (p) => Console.WriteLine($"Transaction vm state is  {(await p).VMState}"));\n')),(0,i.kt)("p",null,"Here is the complete code:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'using Neo.Network.P2P.Payloads;\nusing Neo.Network.RPC;\nusing Neo.SmartContract;\nusing Neo.SmartContract.Manifest;\nusing Neo.Wallets;\nusing System;\nusing Neo.IO;\nusing System.IO;\n\nnamespace ConsoleApp1\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Test().GetAwaiter().GetResult();\n            Console.Read();\n        }\n\n        private static async Task Test()\n        {\n            // choose a neo node with rpc opened, here we use the localhost\n            RpcClient client = new RpcClient(new Uri("http://localhost:20332"), null, null, ProtocolSettings.Load("config.json"));\n            ContractClient contractClient = new ContractClient(client);\n\n            string nefFilePath = "sc/Contract1.nef";\n            string manifestFilePath = "sc/Contract1.manifest.json";\n\n            // read nefFile & manifestFile\n            NefFile nefFile;\n            using (var stream = new BinaryReader(File.OpenRead(nefFilePath), Encoding.UTF8, false))\n            {\n                nefFile = stream.ReadSerializable<NefFile>();\n            }\n\n            ContractManifest manifest = ContractManifest.Parse(File.ReadAllBytes(manifestFilePath));\n\n            // deploying contract needs sender to pay the system fee\n            KeyPair senderKey = Utility.GetKeyPair("L53tg72Az8QhYUAyyqTQ3LaXMXBE3S9mJGGZVKHBryZxya7prwhZ");\n\n            // create the deploy transaction\n            Transaction transaction = await contractClient.CreateDeployContractTxAsync(nefFile.ToArray(), manifest, senderKey).ConfigureAwait(false);\n\n            // Broadcast the transaction over the NEO network\n            await client.SendRawTransactionAsync(transaction).ConfigureAwait(false);\n            Console.WriteLine($"Transaction {transaction.Hash.ToString()} is broadcasted!");\n\n            // print a message after the transaction is on chain\n            WalletAPI neoAPI = new WalletAPI(client);\n            await neoAPI.WaitTransactionAsync(transaction)\n               .ContinueWith(async (p) => Console.WriteLine($"Transaction vm state is  {(await p).VMState}"));\n        }\n    }\n}\n')),(0,i.kt)("h2",{id:"contract-invocation-simulation"},"Contract invocation simulation"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"ContractClient")," provides the method ",(0,i.kt)("inlineCode",{parentName:"p"},"TestInvokeAsync")," to simulate the contract invocation, which does not affect the data on the chain after execution. You can directly invoke the contract method that reads the data. For example, the following example invokes the name method in the NEO native contract."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// choose a neo node with rpc opened\nRpcClient client = new RpcClient("http://127.0.0.1:10332");\nContractClient contractClient = new ContractClient(client);\n\n// get the contract hash\nUInt160 scriptHash = NativeContract.NEO.Hash;\n\n// test invoking the method provided by the contract \nRpcInvokeResult invokeResult = await contractClient.TestInvokeAsync(scriptHash, "name").ConfigureAwait(false);\nConsole.WriteLine($"The name is {invokeResult.Stack.Single().GetString()}");\n')),(0,i.kt)("p",null,"Or you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"MakeScript")," to construct the script you want to execute and then invoke the method ",(0,i.kt)("inlineCode",{parentName:"p"},"InvokeScriptAsync")," in ",(0,i.kt)("inlineCode",{parentName:"p"},"RpcClient"),"to get the execution result."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// choose a neo node with rpc opened\nRpcClient client = new RpcClient("http://127.0.0.1:10332");\n\n// get the contract hash\nUInt160 scriptHash = NativeContract.NEO.Hash;\n\nbyte[] script = scriptHash.MakeScript("name");\n// call invoke script\nRpcInvokeResult invokeResult = await client.InvokeScriptAsync(script).ConfigureAwait(false);\nConsole.WriteLine($"The name is {invokeResult.Stack.Single().GetString()}");\n')),(0,i.kt)("h2",{id:"contract-invocation-on-chain-transactions"},"Contract invocation (on-chain transactions)"),(0,i.kt)("p",null,"Generally invoking a deployed contract on the blockchain contains the following steps:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Construct the script to invoke"),(0,i.kt)("p",{parentName:"li"},"Take the ",(0,i.kt)("inlineCode",{parentName:"p"},"transfer")," method of native contract Neo as an example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// construct the script, in this example, we will transfer 1024 NEO to receiver\nUInt160 scriptHash = NativeContract.NEO.Hash;\nbyte[] script = scriptHash.MakeScript("transfer", sender, receiver, 1024);\n'))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Construct the transaction\uff1a"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// initialize the TransactionManagerFactory with rpc client and magic\n// fill the script and cosigners\nTransactionManager txManager = await new TransactionManagerFactory(client, 5195086)\n    .MakeTransactionAsync(script, cosigners).ConfigureAwait(false);\n// add signature and sign transaction with the added signature\nTransaction tx = await txManager.AddSignature(sendKey).SignAsync().ConfigureAwait(false);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Broadcast the transaction on the blockchain:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"// broadcasts the transaction over the Neo network\nawait client.SendRawTransactionAsync(tx).ConfigureAwait(false);\n"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Wait until the transaction is added to the blockchain and then get the transaction execution status to make sure the contract is invoked successfully:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// print a message after the transaction is on chain\nWalletAPI neoAPI = new WalletAPI(client);\nawait neoAPI.WaitTransactionAsync(tx)\n    .ContinueWith(async (p) => Console.WriteLine($"Transaction vm state is  {(await p).VMState}"));\n')))),(0,i.kt)("p",null,"For complete code refer to ",(0,i.kt)("a",{parentName:"p",href:"/website/docs/n3/develop/tool/sdk/transaction"},"Transaction Construction"),"."),(0,i.kt)("h2",{id:"nep-17-contracts"},"NEP-17 Contracts"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"Nep17API")," encapsulates the method that generates transfer transactions. The above transaction process can be simplified to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},"Nep17API nep17API = new Nep17API(client);\nTransaction tx = await nep17API.CreateTransferTxAsync(scriptHash, sendKey, receiver, 1).ConfigureAwait(false);\n")),(0,i.kt)("p",null,"Additionally, ",(0,i.kt)("inlineCode",{parentName:"p"},"Nep17API")," also provides a set of simple methods to get data:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cs"},'// get nep17 name\nstring name = await nep17API.NameAsync(NativeContract.NEO.Hash).ConfigureAwait(false);\n\n// get nep17 symbol\nstring symbol = await nep17API.SymbolAsync(NativeContract.NEO.Hash).ConfigureAwait(false);\n\n// get nep17 token decimals\nbyte decimals = await nep17API.DecimalsAsync(NativeContract.NEO.Hash).ConfigureAwait(false);\n\n// get nep17 token total supply\nBigInteger totalSupply = await nep17API.TotalSupplyAsync(NativeContract.NEO.Hash).ConfigureAwait(false);\n\n// get the balance of nep17 token\nUInt160 account = Utility.GetScriptHash("NXjtqYERuvSWGawjVux8UerNejvwdYg7eE");\nBigInteger balance = await nep17API.BalanceOfAsync(NativeContract.NEO.Hash, account).ConfigureAwait(false);\n\n// get token information\nRpcNep17TokenInfo tokenInfo = await nep17API.GetTokenInfoAsync(NativeContract.NEO.Hash).ConfigureAwait(false);\n')))}u.isMDXComponent=!0}}]);