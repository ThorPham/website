"use strict";(self.webpackChunkneo_dev_portal=self.webpackChunkneo_dev_portal||[]).push([[202],{3905:function(e,t,r){r.d(t,{Zo:function(){return u},kt:function(){return f}});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),s=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=s(e.components);return n.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),d=s(r),f=o,k=d["".concat(c,".").concat(f)]||d[f]||p[f]||a;return r?n.createElement(k,i(i({ref:t},u),{},{components:r})):n.createElement(k,i({ref:t},u))}));function f(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,i[1]=l;for(var s=2;s<a;s++)i[s]=r[s];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},30611:function(e,t,r){r.r(t),r.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return u},default:function(){return d}});var n=r(87462),o=r(63366),a=(r(67294),r(3905)),i=["components"],l={},c="Merkle Tree",s={unversionedId:"n3/foundation/Cryptography/MerkleTree",id:"n3/foundation/Cryptography/MerkleTree",isDocsHomePage:!1,title:"Merkle Tree",description:"A Merkle tree is a kind of binary tree: It's able to quickly check and induce massive data and verify the completeness of block transaction records. Neo uses Merkle tree to construct block model. Neo's block head stores the Merkle root of all transactions within the block. The block data area stores transaction array.",source:"@site/docs/n3/foundation/Cryptography/MerkleTree.md",sourceDirName:"n3/foundation/Cryptography",slug:"/n3/foundation/Cryptography/MerkleTree",permalink:"/website/docs/n3/foundation/Cryptography/MerkleTree",editUrl:"https://github.com/neo-project/neo-dev-portal/blob/master/docs/n3/foundation/Cryptography/MerkleTree.md",tags:[],version:"current",lastUpdatedBy:"Apisit Toompkadee",frontMatter:{},sidebar:"docs",previous:{title:"Transactions",permalink:"/website/docs/n3/foundation/Transactions"},next:{title:"Encoding Algorithm",permalink:"/website/docs/n3/foundation/Cryptography/encode_algorithm"}},u=[{value:"Usage Scenarios",id:"usage-scenarios",children:[]}],p={toc:u};function d(e){var t=e.components,l=(0,o.Z)(e,i);return(0,a.kt)("wrapper",(0,n.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"merkle-tree"},"Merkle Tree"),(0,a.kt)("p",null,"A Merkle tree is a kind of binary tree: It's able to quickly check and induce massive data and verify the completeness of block transaction records. Neo uses Merkle tree to construct block model. Neo's block head stores the Merkle root of all transactions within the block. The block data area stores transaction array.  "),(0,a.kt)("p",null,(0,a.kt)("img",{src:r(40782).Z})),(0,a.kt)("p",null,"Attribute of Merkle tree\uff1a"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Merkle tree is basicly a binary tree, with all features of tree structure."),(0,a.kt)("li",{parentName:"ol"},"Merkle tree's leaf nodes' value is unit data of data set, or unit data HASH."),(0,a.kt)("li",{parentName:"ol"},"The value of a non-leaf node is based on all the leaf node values below it, and then calculated with hash method.")),(0,a.kt)("p",null,"Transaction verification principle:"),(0,a.kt)("p",null,"Transaction001's validity can be verified by comparing original Top Hash value with the value computed from Transaction001, Transaction002 and Hash1(The direct child of Top Hash on the right side)."),(0,a.kt)("h2",{id:"usage-scenarios"},"Usage Scenarios"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Builds a Merkle tree root when constructing a block header"),(0,a.kt)("li",{parentName:"ul"},"Verifies the block data using SPV wallets."),(0,a.kt)("li",{parentName:"ul"},"As a data structure, generates a stateRoot for Neo blocks. This is used in cross-chain and light node scenarios for quickly verifying the validity of blocks.")))}d.isMDXComponent=!0},40782:function(e,t,r){t.Z=r.p+"assets/images/MerkleTree01-b8b2a4e6280e9ec63612f107a670c149.png"}}]);