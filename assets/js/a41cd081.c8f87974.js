"use strict";(self.webpackChunkneo_dev_portal=self.webpackChunkneo_dev_portal||[]).push([[2200],{3905:function(e,t,a){a.d(t,{Zo:function(){return s},kt:function(){return u}});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function o(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?o(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):o(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)a=o[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var p=n.createContext({}),c=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=c(e.components);return n.createElement(p.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,o=e.originalType,p=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),m=c(a),u=r,h=m["".concat(p,".").concat(u)]||m[u]||d[u]||o;return a?n.createElement(h,i(i({ref:t},s),{},{components:a})):n.createElement(h,i({ref:t},s))}));function u(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=a.length,i=new Array(o);i[0]=m;var l={};for(var p in t)hasOwnProperty.call(t,p)&&(l[p]=t[p]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var c=2;c<o;c++)i[c]=a[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},81645:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return s},default:function(){return m}});var n=a(87462),r=a(63366),o=(a(67294),a(3905)),i=["components"],l={},p="Encoding Algorithm",c={unversionedId:"n3/foundation/Cryptography/encode_algorithm",id:"n3/foundation/Cryptography/encode_algorithm",isDocsHomePage:!1,title:"Encoding Algorithm",description:"Base58",source:"@site/docs/n3/foundation/Cryptography/encode_algorithm.md",sourceDirName:"n3/foundation/Cryptography",slug:"/n3/foundation/Cryptography/encode_algorithm",permalink:"/website/docs/n3/foundation/Cryptography/encode_algorithm",editUrl:"https://github.com/neo-project/neo-dev-portal/blob/master/docs/n3/foundation/Cryptography/encode_algorithm.md",tags:[],version:"current",lastUpdatedBy:"Apisit",frontMatter:{},sidebar:"docs",previous:{title:"Merkle Tree",permalink:"/website/docs/n3/foundation/Cryptography/MerkleTree"},next:{title:"Encryption Algorithm",permalink:"/website/docs/n3/foundation/Cryptography/encryption_algorithm"}},s=[{value:"Base58",id:"base58",children:[]},{value:"Base58Check",id:"base58check",children:[]}],d={toc:s};function m(e){var t=e.components,l=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,n.Z)({},d,l,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"encoding-algorithm"},"Encoding Algorithm"),(0,o.kt)("h2",{id:"base58"},"Base58"),(0,o.kt)("p",null,"Base58 is a group of encoding/decoding schemes used to switch data between binary format (hexdecimal) and alphanumeric text format (ASCII). Base58 enables data compressing, is easy to identify, and is suitable for constructing encoding mechanism of transmission system that is anti-auto-monitoring. However, lack of verification makes it not able to detect error during transmission. Thus for Base58Check, an improved scheme is required.  "),(0,o.kt)("p",null,"The Base58's alphabet includes numbers (From 1 to 9), and English letters except O (uppercase o) / I (uppercase i) / l (lowercase L). These letters are omitted to avoid confusion."),(0,o.kt)("p",null,"Neo's Base58 alphabet: ",(0,o.kt)("strong",{parentName:"p"},"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz")),(0,o.kt)("p",null,"Interface definition\uff1a"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Encoding method: Encoding byte[] format data into Base58 string format"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"string Encode(byte[] input)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Decoding Method: Decoding Base58 string format data into byte[] format"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"byte[] Decode(string input)\n")))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Encoding Steps"),"\uff1a"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Add 0x00 before byte[] data to generate a new byte array, and then reverse its order (little endian)")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Convert array data to a BigInteger object")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Convert the BigInteger format number to 58-based number according to Base58 alphabet")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Count the number of 0x00 in original byte array format data. At the head of the Base58 format data generated in step 3, for each 0x00, add a letter '1', which is the first character in Base58 alphabet"))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Decoding Steps"),"\uff1a"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Convert the input string into BigInteger format according to Base58 alphabet.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Convert from BigInteger format to byte[] format and then reverse the order to big endian.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"If byte[] format data's length is more than 1 & byte","[0]"," = 0 & byte","[1]"," >= 0x80, start from byte","[1]",", otherwise start from byte","[0]"," to get the decoded result.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Count the number of the first letter of Base58 alphabet in original input data as count and remove leading zeros from the decoded data."))),(0,o.kt)("p",null,"Example:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"String Content"),(0,o.kt)("th",{parentName:"tr",align:null},"byte[]"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"NTRAJ9EEjHFHhHZvMKEKfkceg5V9ppx5ZP"),(0,o.kt)("td",{parentName:"tr",align:null},"[0x35, 0x52, 0x4e, 0x37, 0xb7, 0x01, 0x39, 0xc8, 0x96, 0xeb, 0xd5, 0x4a, 0x86, 0x48, 0xd3, 0xfa, 0x78, 0x6b, 0x26, 0x48, 0x76, 0xea, 0xc5, 0x26, 0xce]")))),(0,o.kt)("p",null,"Scenarios\uff1a"),(0,o.kt)("p",null,"Serves for Base58Check encoding / decoding method."),(0,o.kt)("h2",{id:"base58check"},"Base58Check"),(0,o.kt)("p",null,"Base58Check is an improved encoding / decoding method base on Base58. Base58Check solved the lack of checking mechanism in Base58, by adding hash value to original data as salt."),(0,o.kt)("p",null,"Interface definition:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Encoding method: encode byte array data into checkable Base58 string format"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"string Base58CheckEncode(byte[] input)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Decoding method\uff1adecode checkable Base58 string data into byte array format"),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-cs"},"byte[] Base58CheckDecode(string input)\n")))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Encoding Steps"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Encode input byte array twice with Sha256 to get a hashed byte array. Take the first 4 bytes of the hash as checksum and append it to the end of original byte array.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Use Base58 to encode the byte array including checksum to get corresponding encoded result."))),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Decoding Steps"),":"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Use Base58 to decode input string to get byte array format decoded result.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Take the content of byte array except the last 4 bytes as data.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},"Encode data twice with SHA256 to get a hashed byte array. Check whether the first 4 bytes of the hashed value are identical with the last 4 bytes in byte array of step 1. If so, the decoded data is correct. Otherwise the data is corrupted."))),(0,o.kt)("p",null,"   ",(0,o.kt)("img",{src:a(21147).Z})),(0,o.kt)("p",null,"Example:"),(0,o.kt)("table",null,(0,o.kt)("thead",{parentName:"table"},(0,o.kt)("tr",{parentName:"thead"},(0,o.kt)("th",{parentName:"tr",align:null},"String content"),(0,o.kt)("th",{parentName:"tr",align:null},"byte[]"))),(0,o.kt)("tbody",{parentName:"table"},(0,o.kt)("tr",{parentName:"tbody"},(0,o.kt)("td",{parentName:"tr",align:null},"NTRAJ9EEjHFHhHZvMKEKfkceg5V9ppx5ZP"),(0,o.kt)("td",{parentName:"tr",align:null},"[0x35, 0x52, 0x4e, 0x37, 0xb7, 0x01, 0x39, 0xc8, 0x96, 0xeb, 0xd5, 0x4a, 0x86, 0x48, 0xd3, 0xfa, 0x78, 0x6b, 0x26, 0x48, 0x76]")))),(0,o.kt)("p",null,"Scenarios\uff1a"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Import / export WIF format secret key")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Switch between contract script hash and address")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Import / export NEP2 format secret key"))))}m.isMDXComponent=!0},21147:function(e,t,a){t.Z=a.p+"assets/images/Base58CheckEncodeAndDecode-70c192dc7d57ae326dffa9fb615d7871.png"}}]);